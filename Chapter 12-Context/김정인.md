# Context

---

- 서버는 개별 요청에 대해 메타 데이터 처리를 위한 방법이 필요하다.
  - 메타 데이터는 요청을 정확하게 처리하기 위해 필요한 메타 데이터
  - 요청 처리를 중단해야 하는 시점에 대한 메타 데이터의 두 가지 일반적인 범주로 분류
  - 예시
    - HTTP 서버는 마이크로서비스의 구성으로 요청 체인을 식별하기 위해 추적 ID 사용을 원할 수 있다.
    - 요청이 너무 오래 걸린다면 요청 중단을 할 수 있는 타이머를 설정할 수 있다.


- 다른 많은 언어들은 이와 같은 정보를 저장하기 위해 threadlocal 변수를 사용하고, 특정 운영 체제의 스레드 실행에 데이터를 연결한다.
- 이는 Go 에서는 고루틴이 값을 찾을 때 사용되는 고유 아이디를 가지고 있지 않기 때문에 사용할 수 없다.
- Go 는 Context 를 통해 요청 메타 데이터 문제를 해결했다.


<br />

## Context 소개

- 관용적 Go 는 함수 파라미터를 통해 명시적으로 데이터를 전달하는 것을 권장한다.
- Go 에서 마지막으로 반환 하는 것은 err 인 것처럼, 첫 번째 파라미터는 context 를 사용한다.
- 부모 레벨의 context 를 파리미터로 넘겨 자식 함수에서 context 를 래핑하는 형태를 띈다.


```go
ctx := context.Background()
result, err := logic(ctx, "a string")
```

<br />

- net/http 패키지가 생성 이후에 context api 가 추가되었다. 
- 호환성 약속으로 인해, context.Context 파라미터를 추가하기 위해 http.Handler 인터페이스를 변경할 수가 없었다.
- 그래서 아래와 같이 사용한다.

```go
func Middleware(handler http.Handler) http.Handler {
	return http.HandlerFunc(func(rw http.ResponseWriter, req *http.Request) {
		ctx := req.Context()
		req = req.WithContext(ctx)
		handler.ServeHTTP(rw, req)
})
}
```

- 첫 번째는 미들웨어에서 Context 메서드를 사용하여 요청에서 기존 context 를 추출한다.
- 컨텍스트에 값을 넣은 후에, WithContext 메서드를 사용하여 이전 요청과 현재 생성된 컨텍스트르르 기반으로 새로운 요청을 만든다.
- 마지막으로 handler 에 새로운 요청과 기존 http.ResponseWriter 를 전달하여 호출한다.

```go
func handler(rw http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	if err := req.ParseForm(); err != nil {
		rw.WriteHeader(http.StatusInternalServerError)
		rw.Write([]byte(err.Error()))
    }
	data := req.FormValue("data")
	result, err := logic(ctx, data)
	if err != nil {
        rw.WriteHeader(http.StatusInternalServerError)
		rw.Write([]byte(err.Error()))
		return
	}
	rw.Write([]byte(result))
}

```


<br />


```go
type ServiceCaller struct {
	client *http.Client
}

func (sc ServiceCaller) callAnotherService(ctx context.Context, data string) (string, error) {
	req, err := http.NewRequest(http.MethodGet, "http://example.com?data=" + data, nil)
	if err != nil {
		return "", err
	}
	req = req.WithContext(ctx)
	resp, err := sc.client.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()
	
	if resp.StatusCode != http.StatusOK {
		return "", fmt.Errorf("Unexpected status code %d", resp.StatusCode)
	}
	id, err := processReponse(resp.Body)
	return id, err
}

```

- 위처럼 http Request 를 받은 ctx 를 ```req.WithContext(ctx)``` 로 다시 랩핑하여 사용한다.

<br />

